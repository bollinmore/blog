{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Leetcode log","title":"Home"},{"location":"#leetcode-log","text":"","title":"Leetcode log"},{"location":"about/","text":"Alvin Chen - SuperQ","title":"About"},{"location":"about/#alvin-chen-superq","text":"","title":"Alvin Chen - SuperQ"},{"location":"array/gas_station/","text":"134. Gas Station Source There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique Constraints gas.length == n cost.length == n 1 <= n <= 105 0 <= gas[i], cost[i] <= 104 Concept: One pass algorithm The basic idea is: The total gas must larger than total cost, otherwise there is no way to travel around the circuit. If the tank is less zero , we move the starting point to the next station. Why one pass works is because we assuming the oil is sufficient so we can always reset the starting point if tank + gas - cost < 0 Complexity Time Complexity O(n^2): We have a nested for-loop inside because we need to move root node. Space Complexity O(n): Extra space to hold the number of unique BST of N. Code: class Solution { public: int canCompleteCircuit(vector<int>& gas, vector<int>& cost) { /** 2022/1/21 -- O(n), O(1); One pass */ int tank = 0; int start = 0, total_gas = 0, total_cost = 0; for (int i=0; i<gas.size(); i++) { total_gas += gas[i]; total_cost += cost[i]; tank += (gas[i] - cost[i]); if (tank < 0) { // start = i+1; tank = 0; } } return (total_gas >= total_cost) ? start : -1; } };","title":"134. Gas Station"},{"location":"array/gas_station/#134-gas-station","text":"Source There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique Constraints gas.length == n cost.length == n 1 <= n <= 105 0 <= gas[i], cost[i] <= 104","title":"134. Gas Station"},{"location":"array/gas_station/#concept","text":"One pass algorithm The basic idea is: The total gas must larger than total cost, otherwise there is no way to travel around the circuit. If the tank is less zero , we move the starting point to the next station. Why one pass works is because we assuming the oil is sufficient so we can always reset the starting point if tank + gas - cost < 0","title":"Concept:"},{"location":"array/gas_station/#complexity","text":"Time Complexity O(n^2): We have a nested for-loop inside because we need to move root node. Space Complexity O(n): Extra space to hold the number of unique BST of N.","title":"Complexity"},{"location":"array/gas_station/#code","text":"class Solution { public: int canCompleteCircuit(vector<int>& gas, vector<int>& cost) { /** 2022/1/21 -- O(n), O(1); One pass */ int tank = 0; int start = 0, total_gas = 0, total_cost = 0; for (int i=0; i<gas.size(); i++) { total_gas += gas[i]; total_cost += cost[i]; tank += (gas[i] - cost[i]); if (tank < 0) { // start = i+1; tank = 0; } } return (total_gas >= total_cost) ? start : -1; } };","title":"Code:"},{"location":"dp/jump_game/","text":"Jump Game Source You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 105 Concept The idea is to iterate entire loop and set variable reach by max(reach, i+nums[i]) , when the indexer i exceed reach which means we couldn't jump to the end with current value. Code class Solution { public: bool canJump(vector<int>& nums) { /** 2022/1/6 -- O(N), O(1); Greedy */ int n = nums.size(); if (n == 1) return true; int i = 0; for (int reach=0; i<n && i<=reach; i++) { // We add `i<=reach` to let i escape from loop earlier reach = max(reach, i+nums[i]); } return i == n; } };","title":"55. Jump Game"},{"location":"dp/jump_game/#jump-game","text":"Source You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 105","title":"Jump Game"},{"location":"dp/jump_game/#concept","text":"The idea is to iterate entire loop and set variable reach by max(reach, i+nums[i]) , when the indexer i exceed reach which means we couldn't jump to the end with current value.","title":"Concept"},{"location":"dp/jump_game/#code","text":"class Solution { public: bool canJump(vector<int>& nums) { /** 2022/1/6 -- O(N), O(1); Greedy */ int n = nums.size(); if (n == 1) return true; int i = 0; for (int reach=0; i<n && i<=reach; i++) { // We add `i<=reach` to let i escape from loop earlier reach = max(reach, i+nums[i]); } return i == n; } };","title":"Code"},{"location":"dp/jump_game2/","text":"Jump Game II Source Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. You can assume that you can always reach the last index. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 1000 Concept: Code:","title":"45. Jump Game II"},{"location":"dp/jump_game2/#jump-game-ii","text":"Source Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. You can assume that you can always reach the last index. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 1000","title":"Jump Game II"},{"location":"dp/jump_game2/#concept","text":"","title":"Concept:"},{"location":"dp/jump_game2/#code","text":"","title":"Code:"},{"location":"dp/linked_list_cycle2/","text":"142. Linked List Cycle II Source Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Constraints The number of the nodes in the list is in the range [0, 104]. -105 <= Node.val <= 105 pos is -1 or a valid index in the linked-list. Concept: O(1) space complexity Since. (2S = F) consider the part from start - cycle point = A, cycle point- intersect = B, intersect - cycle point = C then slow trival A + B fast travel A + (B+C) * N + B (B+C) is one cycle and * N number we travel the cycles from 2S = F we know (B+C)*N = A + B from (B+C)*N = A + B if we remove B from each side B * (N-1) + C * N = A. then A must be equal to C or eqaul to X * C + Y * B where (X - Y = 1) In other words A mod(B+C) = C. A = B(N-1)+CN =B(N-1)+C(N-1)+C=(B+C)(N-1)+C As a result when we travel from start to point takes A to cycle points and Intersect to cycle points will be same distance or travel M cycles then reach to cycle points (from A mod(b+c) = C); (thats is why we set 1 ptr at start and 1 at intersect and trival at same rate.) Code: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (slow && fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow==fast) { ListNode *start = head; while (slow != start) { start = start->next; slow = slow->next; } return start; } } return nullptr; } };","title":"142. Linked List Cycle II"},{"location":"dp/linked_list_cycle2/#142-linked-list-cycle-ii","text":"Source Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Constraints The number of the nodes in the list is in the range [0, 104]. -105 <= Node.val <= 105 pos is -1 or a valid index in the linked-list.","title":"142. Linked List Cycle II"},{"location":"dp/linked_list_cycle2/#concept","text":"O(1) space complexity Since. (2S = F) consider the part from start - cycle point = A, cycle point- intersect = B, intersect - cycle point = C then slow trival A + B fast travel A + (B+C) * N + B (B+C) is one cycle and * N number we travel the cycles from 2S = F we know (B+C)*N = A + B from (B+C)*N = A + B if we remove B from each side B * (N-1) + C * N = A. then A must be equal to C or eqaul to X * C + Y * B where (X - Y = 1) In other words A mod(B+C) = C. A = B(N-1)+CN =B(N-1)+C(N-1)+C=(B+C)(N-1)+C As a result when we travel from start to point takes A to cycle points and Intersect to cycle points will be same distance or travel M cycles then reach to cycle points (from A mod(b+c) = C); (thats is why we set 1 ptr at start and 1 at intersect and trival at same rate.)","title":"Concept:"},{"location":"dp/linked_list_cycle2/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (slow && fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow==fast) { ListNode *start = head; while (slow != start) { start = start->next; slow = slow->next; } return start; } } return nullptr; } };","title":"Code:"},{"location":"dp/minimum_path_sum/","text":"64. Minimum Path Sum Source Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Constraints m == grid.length n == grid[i].length 1 <= m, n <= 200 0 <= grid[i][j] <= 100 Concept The idea is similar to Unique Paths problem, but we use a two dimension array with size m+1 x n+1. The reason that adding one to m & n is to compare value between extended cell with incoming grid. What we do to find out the solution is implement as below: Create a two dimension array a[m+1][n+1] Initialize the last row and column to all INT_MAX . (Here is a common straegy to find out the minimum from two values.) Set a[m][n-1] to zero because we want to get the smallest value in the first time. Iterate cell starting from the last cell in the grid. Find out the smaller value from the two adjacent nodes(right/down) and plus current cell. Repeat this step until we reach the first cell in the grid. The final answer is in a[0][0] Complexity Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(m*n): An extra space to hold the value when calculating the minimum path. Code class Solution { public: int minPathSum(vector<vector<int>>& grid) { /** 2022/1/7 -- 8ms, 9.8mb; O(m*n), O(m*n); DP, Copy cat */ int m = grid.size(), n = grid[0].size(); int rec[m+1][n+1]; for (int i=0; i<n; i++) rec[m][i] = INT_MAX; for (int i=0; i<m; i++) rec[i][n] = INT_MAX; rec[m][n-1] = 0; // Either `rec[m][n-1] = 0` or `rec[m-1][n] = 0` could let the min() work. for (int i=m-1; i>=0; i--) { for (int j=n-1; j>=0; j--) { rec[i][j] = grid[i][j] + min(rec[i+1][j], rec[i][j+1]); } } return rec[0][0]; } };","title":"64. Minimum Path Sum"},{"location":"dp/minimum_path_sum/#64-minimum-path-sum","text":"Source Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Constraints m == grid.length n == grid[i].length 1 <= m, n <= 200 0 <= grid[i][j] <= 100","title":"64. Minimum Path Sum"},{"location":"dp/minimum_path_sum/#concept","text":"The idea is similar to Unique Paths problem, but we use a two dimension array with size m+1 x n+1. The reason that adding one to m & n is to compare value between extended cell with incoming grid. What we do to find out the solution is implement as below: Create a two dimension array a[m+1][n+1] Initialize the last row and column to all INT_MAX . (Here is a common straegy to find out the minimum from two values.) Set a[m][n-1] to zero because we want to get the smallest value in the first time. Iterate cell starting from the last cell in the grid. Find out the smaller value from the two adjacent nodes(right/down) and plus current cell. Repeat this step until we reach the first cell in the grid. The final answer is in a[0][0]","title":"Concept"},{"location":"dp/minimum_path_sum/#complexity","text":"Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(m*n): An extra space to hold the value when calculating the minimum path.","title":"Complexity"},{"location":"dp/minimum_path_sum/#code","text":"class Solution { public: int minPathSum(vector<vector<int>>& grid) { /** 2022/1/7 -- 8ms, 9.8mb; O(m*n), O(m*n); DP, Copy cat */ int m = grid.size(), n = grid[0].size(); int rec[m+1][n+1]; for (int i=0; i<n; i++) rec[m][i] = INT_MAX; for (int i=0; i<m; i++) rec[i][n] = INT_MAX; rec[m][n-1] = 0; // Either `rec[m][n-1] = 0` or `rec[m-1][n] = 0` could let the min() work. for (int i=m-1; i>=0; i--) { for (int j=n-1; j>=0; j--) { rec[i][j] = grid[i][j] + min(rec[i+1][j], rec[i][j+1]); } } return rec[0][0]; } };","title":"Code"},{"location":"dp/unique_binary_search_trees/","text":"96. Unique Binary Search Trees Source Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. Constraints 1 <= n <= 19 Concept: The idea is to solve sub problem in dynamic programming. When n = 0 or n = 1 , there's 1 possible BST exists. But when the n >= 2 that means we could break down this problem into sub problem as below: n==2: left nodes + root + right nodes 2 1 / or \\ 1 2 So we can turn this problem into Find out the combination while iterate the nodes, the formula of each combination will be numTrees(left) * numTrees(right) , then we can sum up the number because we want to know how many unique BST exists for N. Complexity Time Complexity O(n^2): We have a nested for-loop inside because we need to move root node. Space Complexity O(n): Extra space to hold the number of unique BST of N. Code: class Solution { public: int numTrees(int n) { if (n<=1) return 1; vector<int> dp(n+1, 1); // 0-> 1; 1->1 for (int nodes=2; nodes<=n; nodes++) { int total = 0; for (int root=1; root<=nodes; root++) { int left = root - 1; int right = nodes - root; total += dp[left] * dp[right]; } dp[nodes] = total; } return dp.back(); } };","title":"96. Unique Binary Search Trees"},{"location":"dp/unique_binary_search_trees/#96-unique-binary-search-trees","text":"Source Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. Constraints 1 <= n <= 19","title":"96. Unique Binary Search Trees"},{"location":"dp/unique_binary_search_trees/#concept","text":"The idea is to solve sub problem in dynamic programming. When n = 0 or n = 1 , there's 1 possible BST exists. But when the n >= 2 that means we could break down this problem into sub problem as below: n==2: left nodes + root + right nodes 2 1 / or \\ 1 2 So we can turn this problem into Find out the combination while iterate the nodes, the formula of each combination will be numTrees(left) * numTrees(right) , then we can sum up the number because we want to know how many unique BST exists for N.","title":"Concept:"},{"location":"dp/unique_binary_search_trees/#complexity","text":"Time Complexity O(n^2): We have a nested for-loop inside because we need to move root node. Space Complexity O(n): Extra space to hold the number of unique BST of N.","title":"Complexity"},{"location":"dp/unique_binary_search_trees/#code","text":"class Solution { public: int numTrees(int n) { if (n<=1) return 1; vector<int> dp(n+1, 1); // 0-> 1; 1->1 for (int nodes=2; nodes<=n; nodes++) { int total = 0; for (int root=1; root<=nodes; root++) { int left = root - 1; int right = nodes - root; total += dp[left] * dp[right]; } dp[nodes] = total; } return dp.back(); } };","title":"Code:"},{"location":"dp/unique_paths/","text":"62. Unique Paths Source There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Constraints 1 <= m, n <= 100 Concept: 28 21 15 10 6 3 1 7 6 5 4 3 2 1 1 1 1 1 1 1 1 The idea is is to solve sub problem start from the bottom-right: Create a 2D array to hold every possible path to the desitination. Set the value of bottom row to all 1 because there's only one way to each cell. Sum up the value in right & bottom of each cell => It shows how much ways to the destination starting from current cell. We'd get final answer at grid[0][0] Complexity Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(n): We use a vector to hold the date of previous row, and update it when we finish iterating current row. Code: class Solution { public: int uniquePaths(int m, int n) { /** 2022/1/6 -- 7ms, 6.3mb; O(m*n), O(n); DP */ vector<int> vx(n, 1); // n * 1 for (int i=0; i<m-1; i++) { // Because we've set the bottom row to all 1 vector<int> vNew(n, 1); // Since we want the last element become 1 for (int j=n-2; j>=0; j--) { // Because the last column is always 1 vNew[j] = vNew[j+1] + vx[j]; } vx.assign(vNew.begin(), vNew.end()); } return vx[0]; } };","title":"62. Unique Paths"},{"location":"dp/unique_paths/#62-unique-paths","text":"Source There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Constraints 1 <= m, n <= 100","title":"62. Unique Paths"},{"location":"dp/unique_paths/#concept","text":"28 21 15 10 6 3 1 7 6 5 4 3 2 1 1 1 1 1 1 1 1 The idea is is to solve sub problem start from the bottom-right: Create a 2D array to hold every possible path to the desitination. Set the value of bottom row to all 1 because there's only one way to each cell. Sum up the value in right & bottom of each cell => It shows how much ways to the destination starting from current cell. We'd get final answer at grid[0][0]","title":"Concept:"},{"location":"dp/unique_paths/#complexity","text":"Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(n): We use a vector to hold the date of previous row, and update it when we finish iterating current row.","title":"Complexity"},{"location":"dp/unique_paths/#code","text":"class Solution { public: int uniquePaths(int m, int n) { /** 2022/1/6 -- 7ms, 6.3mb; O(m*n), O(n); DP */ vector<int> vx(n, 1); // n * 1 for (int i=0; i<m-1; i++) { // Because we've set the bottom row to all 1 vector<int> vNew(n, 1); // Since we want the last element become 1 for (int j=n-2; j>=0; j--) { // Because the last column is always 1 vNew[j] = vNew[j+1] + vx[j]; } vx.assign(vNew.begin(), vNew.end()); } return vx[0]; } };","title":"Code:"},{"location":"math/add_two_numbers/","text":"2. Add Two Numbers Source You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Constraints The number of nodes in each linked list is in the range [1, 100]. 0 <= Node.val <= 9 It is guaranteed that the list represents a number that does not have leading zeros. Concept: Algorithm: Create a dummy node and a pointer curr which point to the dummy node. Create a variable carry as a flag to know if there's a carry bit been set. Visit l1 & l2 iterately, sum up l1 or l2 if it's not null. We need to add carry if it present' Update the carry flag by set carry=sum/10 every time. Create a new node with value tmp%10 and let curr point to that address. Move pointer curr to the next by curr = curr->next Repeart until l1 & l2 are visited both. Remember to create a new node if the carry flag is set. Complexity Time Complexity O(n): Where n is max(l1.length, l2.length). Space Complexity O(n): Where n is max(l1.length, l2.length). Code: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *p=l1, *q=l2, *dummy, *curr; int carry=0; dummy = new ListNode(); curr = dummy; // a pointer to the dummy node while (p || q) { int tmp = 0 + carry; if (p) tmp += p->val; if (q) tmp += q->val; carry = tmp/10; curr->next = new ListNode(tmp%10); // make link to the dummy curr = curr->next; // move curr pointer to next one if (p) p = p->next; if (q) q = q->next; } if (carry) // ethier 0 or 1 curr->next = new ListNode(carry); return dummy->next; } };","title":"2. Add Two Numbers"},{"location":"math/add_two_numbers/#2-add-two-numbers","text":"Source You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Constraints The number of nodes in each linked list is in the range [1, 100]. 0 <= Node.val <= 9 It is guaranteed that the list represents a number that does not have leading zeros.","title":"2. Add Two Numbers"},{"location":"math/add_two_numbers/#concept","text":"Algorithm: Create a dummy node and a pointer curr which point to the dummy node. Create a variable carry as a flag to know if there's a carry bit been set. Visit l1 & l2 iterately, sum up l1 or l2 if it's not null. We need to add carry if it present' Update the carry flag by set carry=sum/10 every time. Create a new node with value tmp%10 and let curr point to that address. Move pointer curr to the next by curr = curr->next Repeart until l1 & l2 are visited both. Remember to create a new node if the carry flag is set.","title":"Concept:"},{"location":"math/add_two_numbers/#complexity","text":"Time Complexity O(n): Where n is max(l1.length, l2.length). Space Complexity O(n): Where n is max(l1.length, l2.length).","title":"Complexity"},{"location":"math/add_two_numbers/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *p=l1, *q=l2, *dummy, *curr; int carry=0; dummy = new ListNode(); curr = dummy; // a pointer to the dummy node while (p || q) { int tmp = 0 + carry; if (p) tmp += p->val; if (q) tmp += q->val; carry = tmp/10; curr->next = new ListNode(tmp%10); // make link to the dummy curr = curr->next; // move curr pointer to next one if (p) p = p->next; if (q) q = q->next; } if (carry) // ethier 0 or 1 curr->next = new ListNode(carry); return dummy->next; } };","title":"Code:"},{"location":"math/reverse_integer/","text":"7. Reverse Integer Source Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned). Constraints -231 <= x <= 231 - 1 Concept The limitation that you could NOT use a long or long long to store a temporary data, so we might consider the edge case that could prevent overflow or underflow during checking each digit, the algorithm will be: Detect the input value is negative or not and use a flag to hold it. Set the absolute value of x to y to make the codes easy to implement. Check the y>0 iterately and get remaining r . Calculate the temporary answer by v = v*10 +r , but the key point is: if v > INT_MAX/10 , return 0 if v == INT_MAX/10 && r > 7 , return 0 Return the correct answer with previous sign flag. Why we need to return 0 in some condition? It's because any number larger than INT_MAX/10 cannot be multipied by 10 or it would get overflow exception. Complexity Time Complexity O(log(n)): It's roughly equal log 10 (n). Space Complexity O(1) Code class Solution { public: int reverse(int x) { int v=0; int sign = x>=0; int y = abs(x); while (y>0) { int r = y%10; if (v > INT_MAX/10) // v >= 214748365 return 0; if (v==INT_MAX/10 && r>7) // v >= 214748364 && r > 7 return 0; v = v*10 + r; y /= 10; } return sign ? v : 0-v; } };","title":"7. Reverse Integer"},{"location":"math/reverse_integer/#7-reverse-integer","text":"Source Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned). Constraints -231 <= x <= 231 - 1","title":"7. Reverse Integer"},{"location":"math/reverse_integer/#concept","text":"The limitation that you could NOT use a long or long long to store a temporary data, so we might consider the edge case that could prevent overflow or underflow during checking each digit, the algorithm will be: Detect the input value is negative or not and use a flag to hold it. Set the absolute value of x to y to make the codes easy to implement. Check the y>0 iterately and get remaining r . Calculate the temporary answer by v = v*10 +r , but the key point is: if v > INT_MAX/10 , return 0 if v == INT_MAX/10 && r > 7 , return 0 Return the correct answer with previous sign flag. Why we need to return 0 in some condition? It's because any number larger than INT_MAX/10 cannot be multipied by 10 or it would get overflow exception.","title":"Concept"},{"location":"math/reverse_integer/#complexity","text":"Time Complexity O(log(n)): It's roughly equal log 10 (n). Space Complexity O(1)","title":"Complexity"},{"location":"math/reverse_integer/#code","text":"class Solution { public: int reverse(int x) { int v=0; int sign = x>=0; int y = abs(x); while (y>0) { int r = y%10; if (v > INT_MAX/10) // v >= 214748365 return 0; if (v==INT_MAX/10 && r>7) // v >= 214748364 && r > 7 return 0; v = v*10 + r; y /= 10; } return sign ? v : 0-v; } };","title":"Code"},{"location":"snippet/random_negative_int/","text":"Generate random number contains negative values int a = (rand() % 2000) - 1000; // -1000 ~ 999","title":"Generate random negative integer"},{"location":"snippet/random_negative_int/#generate-random-number-contains-negative-values","text":"int a = (rand() % 2000) - 1000; // -1000 ~ 999","title":"Generate random number contains negative values"}]}