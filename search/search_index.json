{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Leetcode log","title":"Home"},{"location":"#leetcode-log","text":"","title":"Leetcode log"},{"location":"about/","text":"Alvin Chen - SuperQ","title":"About"},{"location":"about/#alvin-chen-superq","text":"","title":"Alvin Chen - SuperQ"},{"location":"dp/jump_game/","text":"Jump Game Source You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 105 Concept The idea is to iterate entire loop and set variable reach by max(reach, i+nums[i]) , when the indexer i exceed reach which means we couldn't jump to the end with current value. Code class Solution { public: bool canJump(vector<int>& nums) { /** 2022/1/6 -- O(N), O(1); Greedy */ int n = nums.size(); if (n == 1) return true; int i = 0; for (int reach=0; i<n && i<=reach; i++) { // We add `i<=reach` to let i escape from loop earlier reach = max(reach, i+nums[i]); } return i == n; } };","title":"55. Jump Game"},{"location":"dp/jump_game/#jump-game","text":"Source You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 105","title":"Jump Game"},{"location":"dp/jump_game/#concept","text":"The idea is to iterate entire loop and set variable reach by max(reach, i+nums[i]) , when the indexer i exceed reach which means we couldn't jump to the end with current value.","title":"Concept"},{"location":"dp/jump_game/#code","text":"class Solution { public: bool canJump(vector<int>& nums) { /** 2022/1/6 -- O(N), O(1); Greedy */ int n = nums.size(); if (n == 1) return true; int i = 0; for (int reach=0; i<n && i<=reach; i++) { // We add `i<=reach` to let i escape from loop earlier reach = max(reach, i+nums[i]); } return i == n; } };","title":"Code"},{"location":"dp/jump_game2/","text":"Jump Game II Source Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. You can assume that you can always reach the last index. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 1000 Concept: Code:","title":"45. Jump Game II"},{"location":"dp/jump_game2/#jump-game-ii","text":"Source Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. You can assume that you can always reach the last index. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 1000","title":"Jump Game II"},{"location":"dp/jump_game2/#concept","text":"","title":"Concept:"},{"location":"dp/jump_game2/#code","text":"","title":"Code:"},{"location":"dp/linked_list_cycle2/","text":"142. Linked List Cycle II Source Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Constraints The number of the nodes in the list is in the range [0, 104]. -105 <= Node.val <= 105 pos is -1 or a valid index in the linked-list. Concept: O(1) space complexity Since. (2S = F) consider the part from start - cycle point = A, cycle point- intersect = B, intersect - cycle point = C then slow trival A + B fast travel A + (B+C) * N + B (B+C) is one cycle and * N number we travel the cycles from 2S = F we know (B+C)*N = A + B from (B+C)*N = A + B if we remove B from each side B * (N-1) + C * N = A. then A must be equal to C or eqaul to X * C + Y * B where (X - Y = 1) In other words A mod(B+C) = C. A = B(N-1)+CN =B(N-1)+C(N-1)+C=(B+C)(N-1)+C As a result when we travel from start to point takes A to cycle points and Intersect to cycle points will be same distance or travel M cycles then reach to cycle points (from A mod(b+c) = C); (thats is why we set 1 ptr at start and 1 at intersect and trival at same rate.) Code: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (slow && fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow==fast) { ListNode *start = head; while (slow != start) { start = start->next; slow = slow->next; } return start; } } return nullptr; } };","title":"142. Linked List Cycle II"},{"location":"dp/linked_list_cycle2/#142-linked-list-cycle-ii","text":"Source Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Constraints The number of the nodes in the list is in the range [0, 104]. -105 <= Node.val <= 105 pos is -1 or a valid index in the linked-list.","title":"142. Linked List Cycle II"},{"location":"dp/linked_list_cycle2/#concept","text":"O(1) space complexity Since. (2S = F) consider the part from start - cycle point = A, cycle point- intersect = B, intersect - cycle point = C then slow trival A + B fast travel A + (B+C) * N + B (B+C) is one cycle and * N number we travel the cycles from 2S = F we know (B+C)*N = A + B from (B+C)*N = A + B if we remove B from each side B * (N-1) + C * N = A. then A must be equal to C or eqaul to X * C + Y * B where (X - Y = 1) In other words A mod(B+C) = C. A = B(N-1)+CN =B(N-1)+C(N-1)+C=(B+C)(N-1)+C As a result when we travel from start to point takes A to cycle points and Intersect to cycle points will be same distance or travel M cycles then reach to cycle points (from A mod(b+c) = C); (thats is why we set 1 ptr at start and 1 at intersect and trival at same rate.)","title":"Concept:"},{"location":"dp/linked_list_cycle2/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (slow && fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow==fast) { ListNode *start = head; while (slow != start) { start = start->next; slow = slow->next; } return start; } } return nullptr; } };","title":"Code:"},{"location":"dp/unique_paths/","text":"62. Unique Paths Source There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Constraints 1 <= m, n <= 100 Concept: 28 21 15 10 6 3 1 7 6 5 4 3 2 1 1 1 1 1 1 1 1 The idea is is to solve sub problem start from the bottom-right: Create a 2D array to hold every possible path to the desitination. Set the value of bottom row to all 1 because there's only one way to each cell. Sum up the value in right & bottom of each cell => It shows how much ways to the destination starting from current cell. We'd get final answer at grid[0][0] Complexity Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(n): We use a vector to hold the date of previous row, and update it when we finish iterating current row. Code: class Solution { public: int uniquePaths(int m, int n) { /** 2022/1/6 -- 7ms, 6.3mb; O(m*n), O(n); DP */ vector<int> vx(n, 1); // n * 1 for (int i=0; i<m-1; i++) { // Because we've set the bottom row to all 1 vector<int> vNew(n, 1); // Since we want the last element become 1 for (int j=n-2; j>=0; j--) { // Because the last column is always 1 vNew[j] = vNew[j+1] + vx[j]; } vx.assign(vNew.begin(), vNew.end()); } return vx[0]; } };","title":"62. Unique Paths"},{"location":"dp/unique_paths/#62-unique-paths","text":"Source There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Constraints 1 <= m, n <= 100","title":"62. Unique Paths"},{"location":"dp/unique_paths/#concept","text":"28 21 15 10 6 3 1 7 6 5 4 3 2 1 1 1 1 1 1 1 1 The idea is is to solve sub problem start from the bottom-right: Create a 2D array to hold every possible path to the desitination. Set the value of bottom row to all 1 because there's only one way to each cell. Sum up the value in right & bottom of each cell => It shows how much ways to the destination starting from current cell. We'd get final answer at grid[0][0]","title":"Concept:"},{"location":"dp/unique_paths/#complexity","text":"Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(n): We use a vector to hold the date of previous row, and update it when we finish iterating current row.","title":"Complexity"},{"location":"dp/unique_paths/#code","text":"class Solution { public: int uniquePaths(int m, int n) { /** 2022/1/6 -- 7ms, 6.3mb; O(m*n), O(n); DP */ vector<int> vx(n, 1); // n * 1 for (int i=0; i<m-1; i++) { // Because we've set the bottom row to all 1 vector<int> vNew(n, 1); // Since we want the last element become 1 for (int j=n-2; j>=0; j--) { // Because the last column is always 1 vNew[j] = vNew[j+1] + vx[j]; } vx.assign(vNew.begin(), vNew.end()); } return vx[0]; } };","title":"Code:"}]}