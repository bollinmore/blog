{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Leetcode log","title":"Home"},{"location":"#leetcode-log","text":"","title":"Leetcode log"},{"location":"about/","text":"Alvin Chen - SuperQ","title":"About"},{"location":"about/#alvin-chen-superq","text":"","title":"Alvin Chen - SuperQ"},{"location":"array/gas_station/","text":"134. Gas Station Source There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique Constraints gas.length == n cost.length == n 1 <= n <= 105 0 <= gas[i], cost[i] <= 104 Concept: One pass algorithm The basic idea is: The total gas must larger than total cost, otherwise there is no way to travel around the circuit. If the tank is less zero , we move the starting point to the next station. Why one pass works is because we assuming the oil is sufficient so we can always reset the starting point if tank + gas - cost < 0 Complexity Time Complexity O(n^2): We have a nested for-loop inside because we need to move root node. Space Complexity O(n): Extra space to hold the number of unique BST of N. Code: class Solution { public: int canCompleteCircuit(vector<int>& gas, vector<int>& cost) { /** 2022/1/21 -- O(n), O(1); One pass */ int tank = 0; int start = 0, total_gas = 0, total_cost = 0; for (int i=0; i<gas.size(); i++) { total_gas += gas[i]; total_cost += cost[i]; tank += (gas[i] - cost[i]); if (tank < 0) { // start = i+1; tank = 0; } } return (total_gas >= total_cost) ? start : -1; } };","title":"134. Gas Station"},{"location":"array/gas_station/#134-gas-station","text":"Source There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique Constraints gas.length == n cost.length == n 1 <= n <= 105 0 <= gas[i], cost[i] <= 104","title":"134. Gas Station"},{"location":"array/gas_station/#concept","text":"One pass algorithm The basic idea is: The total gas must larger than total cost, otherwise there is no way to travel around the circuit. If the tank is less zero , we move the starting point to the next station. Why one pass works is because we assuming the oil is sufficient so we can always reset the starting point if tank + gas - cost < 0","title":"Concept:"},{"location":"array/gas_station/#complexity","text":"Time Complexity O(n^2): We have a nested for-loop inside because we need to move root node. Space Complexity O(n): Extra space to hold the number of unique BST of N.","title":"Complexity"},{"location":"array/gas_station/#code","text":"class Solution { public: int canCompleteCircuit(vector<int>& gas, vector<int>& cost) { /** 2022/1/21 -- O(n), O(1); One pass */ int tank = 0; int start = 0, total_gas = 0, total_cost = 0; for (int i=0; i<gas.size(); i++) { total_gas += gas[i]; total_cost += cost[i]; tank += (gas[i] - cost[i]); if (tank < 0) { // start = i+1; tank = 0; } } return (total_gas >= total_cost) ? start : -1; } };","title":"Code:"},{"location":"dp/jump_game/","text":"Jump Game Source You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 105 Concept The idea is to iterate entire loop and set variable reach by max(reach, i+nums[i]) , when the indexer i exceed reach which means we couldn't jump to the end with current value. Code class Solution { public: bool canJump(vector<int>& nums) { /** 2022/1/6 -- O(N), O(1); Greedy */ int n = nums.size(); if (n == 1) return true; int i = 0; for (int reach=0; i<n && i<=reach; i++) { // We add `i<=reach` to let i escape from loop earlier reach = max(reach, i+nums[i]); } return i == n; } };","title":"55. Jump Game"},{"location":"dp/jump_game/#jump-game","text":"Source You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 105","title":"Jump Game"},{"location":"dp/jump_game/#concept","text":"The idea is to iterate entire loop and set variable reach by max(reach, i+nums[i]) , when the indexer i exceed reach which means we couldn't jump to the end with current value.","title":"Concept"},{"location":"dp/jump_game/#code","text":"class Solution { public: bool canJump(vector<int>& nums) { /** 2022/1/6 -- O(N), O(1); Greedy */ int n = nums.size(); if (n == 1) return true; int i = 0; for (int reach=0; i<n && i<=reach; i++) { // We add `i<=reach` to let i escape from loop earlier reach = max(reach, i+nums[i]); } return i == n; } };","title":"Code"},{"location":"dp/jump_game2/","text":"Jump Game II Source Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. You can assume that you can always reach the last index. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 1000 Concept: Code:","title":"45. Jump Game II"},{"location":"dp/jump_game2/#jump-game-ii","text":"Source Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. You can assume that you can always reach the last index. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 1000","title":"Jump Game II"},{"location":"dp/jump_game2/#concept","text":"","title":"Concept:"},{"location":"dp/jump_game2/#code","text":"","title":"Code:"},{"location":"dp/linked_list_cycle2/","text":"142. Linked List Cycle II Source Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Constraints The number of the nodes in the list is in the range [0, 104]. -105 <= Node.val <= 105 pos is -1 or a valid index in the linked-list. Concept: O(1) space complexity Since. (2S = F) consider the part from start - cycle point = A, cycle point- intersect = B, intersect - cycle point = C then slow trival A + B fast travel A + (B+C) * N + B (B+C) is one cycle and * N number we travel the cycles from 2S = F we know (B+C)*N = A + B from (B+C)*N = A + B if we remove B from each side B * (N-1) + C * N = A. then A must be equal to C or eqaul to X * C + Y * B where (X - Y = 1) In other words A mod(B+C) = C. A = B(N-1)+CN =B(N-1)+C(N-1)+C=(B+C)(N-1)+C As a result when we travel from start to point takes A to cycle points and Intersect to cycle points will be same distance or travel M cycles then reach to cycle points (from A mod(b+c) = C); (thats is why we set 1 ptr at start and 1 at intersect and trival at same rate.) Code: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (slow && fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow==fast) { ListNode *start = head; while (slow != start) { start = start->next; slow = slow->next; } return start; } } return nullptr; } };","title":"142. Linked List Cycle II"},{"location":"dp/linked_list_cycle2/#142-linked-list-cycle-ii","text":"Source Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Constraints The number of the nodes in the list is in the range [0, 104]. -105 <= Node.val <= 105 pos is -1 or a valid index in the linked-list.","title":"142. Linked List Cycle II"},{"location":"dp/linked_list_cycle2/#concept","text":"O(1) space complexity Since. (2S = F) consider the part from start - cycle point = A, cycle point- intersect = B, intersect - cycle point = C then slow trival A + B fast travel A + (B+C) * N + B (B+C) is one cycle and * N number we travel the cycles from 2S = F we know (B+C)*N = A + B from (B+C)*N = A + B if we remove B from each side B * (N-1) + C * N = A. then A must be equal to C or eqaul to X * C + Y * B where (X - Y = 1) In other words A mod(B+C) = C. A = B(N-1)+CN =B(N-1)+C(N-1)+C=(B+C)(N-1)+C As a result when we travel from start to point takes A to cycle points and Intersect to cycle points will be same distance or travel M cycles then reach to cycle points (from A mod(b+c) = C); (thats is why we set 1 ptr at start and 1 at intersect and trival at same rate.)","title":"Concept:"},{"location":"dp/linked_list_cycle2/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (slow && fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow==fast) { ListNode *start = head; while (slow != start) { start = start->next; slow = slow->next; } return start; } } return nullptr; } };","title":"Code:"},{"location":"dp/minimum_path_sum/","text":"64. Minimum Path Sum Source Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Constraints m == grid.length n == grid[i].length 1 <= m, n <= 200 0 <= grid[i][j] <= 100 Concept The idea is similar to Unique Paths problem, but we use a two dimension array with size m+1 x n+1. The reason that adding one to m & n is to compare value between extended cell with incoming grid. What we do to find out the solution is implement as below: Create a two dimension array a[m+1][n+1] Initialize the last row and column to all INT_MAX . (Here is a common straegy to find out the minimum from two values.) Set a[m][n-1] to zero because we want to get the smallest value in the first time. Iterate cell starting from the last cell in the grid. Find out the smaller value from the two adjacent nodes(right/down) and plus current cell. Repeat this step until we reach the first cell in the grid. The final answer is in a[0][0] Complexity Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(m*n): An extra space to hold the value when calculating the minimum path. Code class Solution { public: int minPathSum(vector<vector<int>>& grid) { /** 2022/1/7 -- 8ms, 9.8mb; O(m*n), O(m*n); DP, Copy cat */ int m = grid.size(), n = grid[0].size(); int rec[m+1][n+1]; for (int i=0; i<n; i++) rec[m][i] = INT_MAX; for (int i=0; i<m; i++) rec[i][n] = INT_MAX; rec[m][n-1] = 0; // Either `rec[m][n-1] = 0` or `rec[m-1][n] = 0` could let the min() work. for (int i=m-1; i>=0; i--) { for (int j=n-1; j>=0; j--) { rec[i][j] = grid[i][j] + min(rec[i+1][j], rec[i][j+1]); } } return rec[0][0]; } };","title":"64. Minimum Path Sum"},{"location":"dp/minimum_path_sum/#64-minimum-path-sum","text":"Source Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Constraints m == grid.length n == grid[i].length 1 <= m, n <= 200 0 <= grid[i][j] <= 100","title":"64. Minimum Path Sum"},{"location":"dp/minimum_path_sum/#concept","text":"The idea is similar to Unique Paths problem, but we use a two dimension array with size m+1 x n+1. The reason that adding one to m & n is to compare value between extended cell with incoming grid. What we do to find out the solution is implement as below: Create a two dimension array a[m+1][n+1] Initialize the last row and column to all INT_MAX . (Here is a common straegy to find out the minimum from two values.) Set a[m][n-1] to zero because we want to get the smallest value in the first time. Iterate cell starting from the last cell in the grid. Find out the smaller value from the two adjacent nodes(right/down) and plus current cell. Repeat this step until we reach the first cell in the grid. The final answer is in a[0][0]","title":"Concept"},{"location":"dp/minimum_path_sum/#complexity","text":"Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(m*n): An extra space to hold the value when calculating the minimum path.","title":"Complexity"},{"location":"dp/minimum_path_sum/#code","text":"class Solution { public: int minPathSum(vector<vector<int>>& grid) { /** 2022/1/7 -- 8ms, 9.8mb; O(m*n), O(m*n); DP, Copy cat */ int m = grid.size(), n = grid[0].size(); int rec[m+1][n+1]; for (int i=0; i<n; i++) rec[m][i] = INT_MAX; for (int i=0; i<m; i++) rec[i][n] = INT_MAX; rec[m][n-1] = 0; // Either `rec[m][n-1] = 0` or `rec[m-1][n] = 0` could let the min() work. for (int i=m-1; i>=0; i--) { for (int j=n-1; j>=0; j--) { rec[i][j] = grid[i][j] + min(rec[i+1][j], rec[i][j+1]); } } return rec[0][0]; } };","title":"Code"},{"location":"dp/unique_binary_search_trees/","text":"96. Unique Binary Search Trees Source Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. Constraints 1 <= n <= 19 Concept: The idea is to solve sub problem in dynamic programming. When n = 0 or n = 1 , there's 1 possible BST exists. But when the n >= 2 that means we could break down this problem into sub problem as below: n==2: left nodes + root + right nodes 2 1 / or \\ 1 2 So we can turn this problem into Find out the combination while iterate the nodes, the formula of each combination will be numTrees(left) * numTrees(right) , then we can sum up the number because we want to know how many unique BST exists for N. Complexity Time Complexity O(n^2): We have a nested for-loop inside because we need to move root node. Space Complexity O(n): Extra space to hold the number of unique BST of N. Code: class Solution { public: int numTrees(int n) { if (n<=1) return 1; vector<int> dp(n+1, 1); // 0-> 1; 1->1 for (int nodes=2; nodes<=n; nodes++) { int total = 0; for (int root=1; root<=nodes; root++) { int left = root - 1; int right = nodes - root; total += dp[left] * dp[right]; } dp[nodes] = total; } return dp.back(); } };","title":"96. Unique Binary Search Trees"},{"location":"dp/unique_binary_search_trees/#96-unique-binary-search-trees","text":"Source Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. Constraints 1 <= n <= 19","title":"96. Unique Binary Search Trees"},{"location":"dp/unique_binary_search_trees/#concept","text":"The idea is to solve sub problem in dynamic programming. When n = 0 or n = 1 , there's 1 possible BST exists. But when the n >= 2 that means we could break down this problem into sub problem as below: n==2: left nodes + root + right nodes 2 1 / or \\ 1 2 So we can turn this problem into Find out the combination while iterate the nodes, the formula of each combination will be numTrees(left) * numTrees(right) , then we can sum up the number because we want to know how many unique BST exists for N.","title":"Concept:"},{"location":"dp/unique_binary_search_trees/#complexity","text":"Time Complexity O(n^2): We have a nested for-loop inside because we need to move root node. Space Complexity O(n): Extra space to hold the number of unique BST of N.","title":"Complexity"},{"location":"dp/unique_binary_search_trees/#code","text":"class Solution { public: int numTrees(int n) { if (n<=1) return 1; vector<int> dp(n+1, 1); // 0-> 1; 1->1 for (int nodes=2; nodes<=n; nodes++) { int total = 0; for (int root=1; root<=nodes; root++) { int left = root - 1; int right = nodes - root; total += dp[left] * dp[right]; } dp[nodes] = total; } return dp.back(); } };","title":"Code:"},{"location":"dp/unique_paths/","text":"62. Unique Paths Source There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Constraints 1 <= m, n <= 100 Concept: 28 21 15 10 6 3 1 7 6 5 4 3 2 1 1 1 1 1 1 1 1 The idea is is to solve sub problem start from the bottom-right: Create a 2D array to hold every possible path to the desitination. Set the value of bottom row to all 1 because there's only one way to each cell. Sum up the value in right & bottom of each cell => It shows how much ways to the destination starting from current cell. We'd get final answer at grid[0][0] Complexity Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(n): We use a vector to hold the date of previous row, and update it when we finish iterating current row. Code: class Solution { public: int uniquePaths(int m, int n) { /** 2022/1/6 -- 7ms, 6.3mb; O(m*n), O(n); DP */ vector<int> vx(n, 1); // n * 1 for (int i=0; i<m-1; i++) { // Because we've set the bottom row to all 1 vector<int> vNew(n, 1); // Since we want the last element become 1 for (int j=n-2; j>=0; j--) { // Because the last column is always 1 vNew[j] = vNew[j+1] + vx[j]; } vx.assign(vNew.begin(), vNew.end()); } return vx[0]; } };","title":"62. Unique Paths"},{"location":"dp/unique_paths/#62-unique-paths","text":"Source There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Constraints 1 <= m, n <= 100","title":"62. Unique Paths"},{"location":"dp/unique_paths/#concept","text":"28 21 15 10 6 3 1 7 6 5 4 3 2 1 1 1 1 1 1 1 1 The idea is is to solve sub problem start from the bottom-right: Create a 2D array to hold every possible path to the desitination. Set the value of bottom row to all 1 because there's only one way to each cell. Sum up the value in right & bottom of each cell => It shows how much ways to the destination starting from current cell. We'd get final answer at grid[0][0]","title":"Concept:"},{"location":"dp/unique_paths/#complexity","text":"Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(n): We use a vector to hold the date of previous row, and update it when we finish iterating current row.","title":"Complexity"},{"location":"dp/unique_paths/#code","text":"class Solution { public: int uniquePaths(int m, int n) { /** 2022/1/6 -- 7ms, 6.3mb; O(m*n), O(n); DP */ vector<int> vx(n, 1); // n * 1 for (int i=0; i<m-1; i++) { // Because we've set the bottom row to all 1 vector<int> vNew(n, 1); // Since we want the last element become 1 for (int j=n-2; j>=0; j--) { // Because the last column is always 1 vNew[j] = vNew[j+1] + vx[j]; } vx.assign(vNew.begin(), vNew.end()); } return vx[0]; } };","title":"Code:"}]}